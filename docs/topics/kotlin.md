# kotlin study

## kotlin
### 언어의 특징
1. 다른 객체 지향 언어에 비해 상용구가 많이 사라진다.
    - 코드가 간결하다.
2. null에 안전하다.
    - 코드 문법적으로 null에 안전하게 구성되어 있다.
3. 묵시적 형 변환을 금지한다.
4. if를 문이 아니라 식 형태로 구성이 가능하다.
    - 구조가 삼항 연산자와 동일하다.
5. 확장 함수의 가능으로 버전이 달라져도 최신 기능들을 전 버전에서도 사용 가능하다.
---

## 코틀린에서 본 익숙하지 않은 자료형들
```
val, var
설명)
    1. 자료형을 알아서 유추해준다.
    2. val: 상수, var: 변수
```

## 코틀린에서 본 익숙하지 않은 문법들
```
var num : Int = 10
설명)
    자료형 명시를 변수명 뒤에 ":" 작성 후 작성하게 되어있다.
    
fun functionName(a: Int) : Int = return 0
설명)
    1. 함수라고 선언해주어야 한다. (fun)
    2. 반환형을 함수 선언 뒤에 ":" 작성 후 작성한다.
        - void 타입은 Unit
    3. return이 하나일 경우 식으로도 함수의 정의가 가능하다.
```
## 오브젝트와 클래스와 인스턴스
### 오브젝트
#### 개념: 현실 세계에서 객체라 부를 수 있는 모든 대상

### 클래스
#### 개념: 오브젝트를 구성해서 코드 상에 설계한 틀

### 인스턴스
#### 개념: 클래스를 이용해서 실제로 메모리 상에 만들어낸 것

---

## 함수와 메소드의 차이
### 함수
- 동일한 input 값에 동일한 output 값을 반환한다.

### 메소드
- 인스턴스에 따라 동일한 input 값에도 다른 output 값을 반환할 수 있다.

---
# 생성자에 관한 내용들

## 코틀린에서의 생성자 형태
- 코드 상에서 메소드의 형태로 생성자가 존재하지는 않고  
  클래스 명 옆에 괄호의 형태로 존재한다.

## 생성자의 매개 변수 순서
- 다른 언어에서는 생성자의 매개 변수 순서를 지켜서 인스턴스를 생성해야하지만  
  코틀린에서는 그 부분을 신경쓰지 않아도 된다.

## 생성자 매개변수의 초기값 설정
- 생성자 매개변수를 정의해줄 때 초기값을 설정해서  
  인스턴스 생성 시에 아무런 값도 입력하지 않을 수 있다.

---

## 테스트 코드 작성 방법
1. 해당 클래스를 잡고 alt + enter
2. 테스트 코드를 만드는 버튼을 누르면
3. src/test/kotlin에 테스트 코드 파일이 생성된다.

---

## 힙영역과 스택영역
### 힙 영역
- 메모리의 할당과 소멸이 동적으로 이루어지며 사용자의 코드에 따라 유동적이다.
- 정확히는 할당만으로 소멸은 GC가 대신 해준다.
### 스택영역
- 일반 지역 변수들이 스택 영역 메모리 공간에 올라온다.
- 스택의 구조에 따라서 메모리의 할당과 소멸이 이루어진다.

---

## companion object
- 인스턴스 영역이 아니라 클래스 영역이라고 보면 된다.
- 다른 객체지향 문법의 클래스 내 필드의 static 선언과 동일한 특성을 갖는다.

---

## 정보은닉과 캡슐화
### 정보은닉
- 외부에서 클래스 내의 멤버들에 대한 접근을 제한하는 행위
### 캡슐화
- 외부에서 클래스 내의 접근에 대해 제어하는 것
### 차이점
- 캡슐화가 정보은닉을 포함한다고 보면 된다.
- 정보은닉은 제한만을 하지만 캡슐화는 제한만을 하는 것이 아니라  
  외부에서 바람직한 방법으로 사용을 유도하는 것이다.  
  그를 위한 수단 중에 하나가 정보은닉인 것이다.

## 접근제어 지시자
### private
- 클래스 내에서 멤버끼리만 서로 접근 및 호출이 가능하다.
### public
- 외부에서 어느 대상이든 호출이 가능하다.

## 프로퍼티 및 getter, setter
### 프로퍼티
- 외부에서 접근을 허용하고자 하지만 일련의 조건이나 제한을 걸고 싶을 경우 사용한다.
- 그 기능을 제공하기 위해서 getter와 setter를 제공하고 이를 프로퍼티라고 부른다.

## 확장함수와 require
### 확장함수
- 이미 만들어진 클래스에 추가적인 기능을 만들고 싶을 때  
  클래스 내에서 함수를 추가하지 않고도  
  어디서든지 클래스의 이름을 활용해 대상(클래스)만 잘 지정해주면  
  마치 일반 함수처럼 정의가 가능하고 해당 클래스의 함수가 된다.
- 이 문법은 제법 편리해 보인다. 분명히 언젠가는 다시 만날 것 같다.
### require
- 조건문을 사용하여 false일 경우 예외를 던져주는 함수이다.
- 물론 그 일련의 과정을 수행하는 코드를 작성할 수도 있겠지만  
  이 함수를 사용하면 코드가 짧아져 가독성이 향상되는 듯 하다.
- 또한 람다식을 사용하여 예외 발생 시 사용되는 메시지를 전달할 수 있다.

---

## 상속
- 대부분 다른 언어와 동일하나, 기본적으로 상속을 막아놨다는 것이 특이한 점이다.
- 그래서 open 키워드로 선언을 해줘야 상속이 가능하다.

## 오버라이드
- 역시 기본적으로 코틀린에서는 오버라이드도 막아 놨다.
- 그래서 open 키워드 선언을 해줘야 한다.

---

## 추상클래스
- 실제로 인스턴스화할 클래스가 아니라 상속을 하는 것을 목적으로 하는 클래스
- 인터페이스와는 달리 모든 메소드가 추상 메소드일 필요는 없다.

## 인터페이스
- 상속은 받는 클래스가 구현을 해야만 하는 메소드들의 집합
- 추상클래스와는 달리 모든 메소드가 추상메소드로 이루어져 있다.
- 이미 짜여진 설계 속에서 다시 구조적으로 그룹화를 한다거나 예외를 만들어야만 할 경우  
    인터페이스를 사용한다면 유연하게 대처를 할 수가 있다.
- 이러한 점을 미리 생각해서 처음부터 인터페이스로 빼주는 경우도 있다.

## backing field
- 프로퍼티의 실제로 값이 저장되는 구역이다.
- field를 사용하지 않고 getter와 setter를 모두 커스텀하면 backing field가 사용되지 않는 형태가 된다.
- 인터페이스나 추상클래스의 상위클래스에서 backing field가 구성되지 않도록 하면  
  하위클래스에서 반드시 구현할 필요가 없는 듯 하다.

---

## 다형성
- 하나의 대상에 다양한 형태로 볼 수 있는 상황을 의미한다.
- 주로 상속이나 구현 관계에서 상위의 자료형으로  
  하위의 자료형을 담을 수 있는 것에 기인한다.
- 그리고 상위의 프로퍼티나 메소드 등을 오버라이딩한 경우에는  
  자료형이 아닌 실제로 담긴 대상의 프로퍼티나 메소드를 호출한다.

---

## 데이터 클래스
- 데이터를 다루기 위한 클래스
- 그러나 실질적으로는 equals, hashCode, toString, copy 함수를  
  알아서 구현해주는 기능으로 사용한다. 참고로 copy는 얕은 복사

## 깊은 복사
### 필요성
- 기본적으로 클래스에 클래스를 넣거나 기본 구현되는 copy함수를 이용하면  
  멤버 변수들이 그대로 복사가 된다.  
  그 값이 primitive라면 상관이 없다.  
  그러나 String이나 다른 사용자 정의 클래스와 같은 참조변수가 멤버라면 문제가 생긴다.  
  그 멤버변수는 클래스간 공유가 되어 다른 한 쪽의 클래스의 그 멤버변수의 변경 및 소멸에 의존적이게 된다.  
  그러므로 깊은 복사를 해주어야 하는 것이다.
### 하는 법
- 포인트는 카피를 하는 도중 참조변수인 멤버변수를 새로 하나 만들어서 내용을 담아줘야한다는 것이다.

## comparator 인터페이스
- 인터페이스 안에 있는 compare를 구현하게 해서 각종 sorted를 사용하기 위함
- sortedWith, sortedWith, sortedBy 등이 있다.
- 물론 클래스가 comparator를 구현하는 방식으로도 사용할 수도 있지만  
주로 위에서 언급한 함수 사용을 위해 무명 함수 형태로 사용을 한다.

## set, map 인터페이스의 동작 원리
- 리스트와 달리 hashCode비교도 진행된다.  
  그러니 equals와 hashCode함수 모두 작성해주어야 한다.

---

## 각종 문자열 처리 기능들
- substring, replace, split, lowercase, indexOf, isEmpty, contains, endsWith, trim
- 모두 String 객체의 메소드들이다.
- 참고로 String은 불변 객체이므로 객체 내 메소드들은 accessor 성질을 가진다.

## 제네릭
- 원하는 시점에 타입을 정의할 수 있다.
- out: 읽기 전용, 넣는 연산이 안된다.
- in: 쓰기 전용, 꺼내는 연산이 안된다.

## 열거형
- 정해 둔 값만 넣어둘 수 있는 타입이다.
- when 과의 조합으로 모든 처리를 강제할 수 있어 확장 시에 유용하다고 한다.

---

## 예외 처리
- 기본 틀은 java와 동일하다. try catch finally 구문을 사용한다.
- 그리고 throw로 예외를 던져줄 수도 있다.
- 그러나 java와는 다르게 특정 함수 사용에 있어서 예외처리를 강제하지 않는다.  
  특정 함수라 함은 함수 정의 시 throw 선언을 해준 함수들을 의미한다.

## 직렬화와 역직렬화
- 특정 데이터 혹은 데이터의 집합을 말 그대로 직렬하여 나열하는 것을 의미한다.
- 그렇게 직렬화된 데이터를 저장하고 불러올 때 역직렬화를 시도  
  즉, 파싱과정을 통해 다시 코드에서 동작할 수 있는 데이터의 형태로(예를 들어 클래스라면 클래스의 형태로)  
  만들어 코드 상에서 다룬다.
### json
- 그 방식 중 하나가 json이라고 불리는 것 같다.
- json은 key value 값으로 분류되며 정해진 규약대로 데이터를 저장하여야한다.  
  예를 들면, 문자열에는 쌍따옴표를 붙일 것.  
  마지막 데이터 이후 콤마를 붙지지 말 것.  
  등등이 있다.
- json처럼 규약이 되어있으니 파싱하는 과정이 한결 수월해 보이지만  
  코틀린에서는 보다 강력한 기능을 제공해준다.
```
// gradle.kts 파일에 다음과 같은 플러그인을 작성해준다.
// 버전은 다소 낮아도 문제없이 돌아간다.
// 그러니 필요한 경우 플러그인만을 가져가 사용하자.
plugins {
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.serialization") version "2.1.0"
}

// 그리고 다음과 같은 의존성도 주입해준다.
dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.3")
}
```
- 그러고 나서 싱크를 해주면
```
Json.encodeToString(data)
// 이와 같이 encodeToString함수를 사용해 자동으로 String 형식으로 직렬화를 해주며

Json.decodeFromString(data)
// 다음과 같이 역직렬화도 가능하다.
// 이후 얻은 String을 이용하여 json 규약에 맞게 파싱해서 데이터를 사용하면 된다.
```
- 이와 같은 코드로 사용이 가능하다. 참고로 반환값을 받아서 사용하는 것이다.

---

## 디버깅 스킬들
### 로깅
- 실제 문제가 된다고 생각되는 변수 등을 출려해보는 것이다.
- 실제로 가장 많이 해왔던 방법이다.
### 브레이크 포인트
- 문제가 된다고 생각되는 코드 라인에 포인트를 찍고  
  디버깅 모드로 빌드를 해서 포인트를 찍은 시점에서 각종 변수나 메모리의 상태를  
  확인하는 방법이다.
- 로깅과는 다르게 한 번의 빌드로 디버깅 상태에서  
  실행 흐름을 계속해서 이어나갈 수 있다는 장점이 있다.
### 디버거
- 브레이크 포인트에서도 설명한 내용으로 디버깅 도중에서 실행 흐름을  
  이어나가거나 특정 함수로 들어가는 등의 기능을 사용하는 방식이다.
### 스택추적
- 코드가 실행되는 흐름을 역으로 추적하여 확인하는 방식이다.

## 람다와 콜백 그리고 함수형 프로그래밍
### 람다
- 함수를 input 값과 output 값의 형식으로 간소화하여
  -> 기호를 기준으로 함수를 표현하는 방식이다.
- 람다를 사용하면 함수를 따로 형식을 맞춰서 정의할 필요 없이  
  필요한 상황에서 바로 만들어 사용할 수 있다.
- 그러나 복잡한 함수를 정의해야 하는 상황에서의 효용성은  
  떨어질 것이라 생각한다.
- 마치 매크로 함수를 정의해 주는 듯 한 느낌을 다소 받는다.
### 콜백
- 함수를 매개변수로 받아 내부에서 사용하는 함수의 형태이다.
- 외부에서는 매개변수를 만족시킬 만한 람다식을 전달해주고  
  내부에서 내부 로직을 통해 해당 람다식이 실행될 것을 기대하는 그런 구조이다.
### 함수형 프로그래밍
- 이렇듯 데이터의 처리를 함수의 형태로 진행하는 방식인  
  함수형 프로그래밍이 등장하게 된다.

---

## 동기 vs 비동기
### 동기
- 코드 순서대로 실행 흐름이 유지
### 비동기
- 주 실행 흐름에서 벗어나 또 다른 실행 흐름을 생성

## 코루틴
- 코루틴은 비동기 방식이다.
### suspend
- 비동기 방식의 실행 흐름을 가져갈 함수에 붙여주는 키워드.
- 실행을 중단 시킨다는 의미를 담고 있다.
### runBlocking
- 코루틴과 일반 코드를 연결 시켜준다.
- 주로 main 함수에서 비동기 방식의 함수를 사용할 때  
  main 함수에 적용시켜준다.
### launch
- 코루틴 빌더 블록 중 하나로 비동기 작업을 위한 블록을 생성한다.
- 결과 값이 필요 없는 경우에 사용한다.
### async
- 마찬가지로 비동기 작업을 위한 블록을 생성한다.
- 그러나 launch와는 달리 반환 값이 필요한 경우 사용한다.
- Deferred<T>를 반환하며 await로 차후 필요한 시점에서 반환 값을 받아 사용하면 된다.
### delay
- delay 또한 일종의 suspend 함수로 실행 흐름을 정지 시킬 수 있다.
### Job
- launch 블록의 경우 Job을 반환하는데 이 Job을 통해 코루틴을 제어할 수 있다.
- join 함수의 경우 코루틴의 처리를 기다리게 할 수 있고
- cancel 함수의 경우 코루틴을 취소 시킬 수 있다.
### Dispatchers
- 코루틴을 통해 여러 실행 흐름을 가져갈 수 있는데
- 그 실행 흐름에서도 나름의 분류를 가지고 필요한 처리를 해 줄 수 있다.
- Default, Main, IO, Unconfied 등 여러 종류가 있고
- withContext와 함께 사용이 된다.
```
withContext(Dispatchers.IO) {
    // 이런식으로 withContext를 이용해 블럭을 생성하고
    // 매개변수 느낌으로 Dispatcher를 이용해 실행 흐름의 종류를 정해준다.
}
```

---

## 데이터 소스
- 가공되지 않은 원천 재료이다.
- 이러한 데이터 소스들은 아래의 종류와 같은 형태로 저장되어 있으며  
  필요시 파일을 불러 들여 파싱 라이브러리를 사용하거나  
  직접 파싱하여 원하는 데이터로(예를 들면 데이터 클래스를 정의하여)  
  가공하여 사용한다. 
### 종류햐
- Text
- File
- JSON
- XML
- CSV
- RDBMS
- NoSQL 등등

## 데이터 소스 구현체의 이름 규칙
### 저장소 유형별 구현체
- 예시) 로컬저장소, 원격저장소, 캐시, 파일, DB, 네트워크 등등
### 구체적인 기술 스택별 구현체
- 예시) Room DB, SQLite, Retrofit, SharedPreferences 등등