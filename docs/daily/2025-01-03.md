# 2025-01-03

## 📚 오늘 배운 내용

### 비동기 프로그래밍

- 동기: 한 작업이 끝날때까지 기다렸다가 다음 작업을 시작함
    - 코드가 순서대로 실행된다
    - 작업이 완료될 때까지 프로그램이 중단될 수 없다
    - 모든 작업은 이전 작업의 실행이 완료될 때까지 기다려야 한다
    - 코드의 실행 순서가 예측 가능하다
- 비동기: 기다리지 않고 다른 작업을 시작함
    - 여러 작업이 병렬로 실행될 수 있다
    - 한 작업이 완료 여부와 관계없이 다음 작업을 시작할 수 있다
    - 작업의 완료 순서를 예측할 수 없다
    - I/O 작업이나 네트워크 요청과 같이 시간이 오래 걸리는 작업에 유용하다
- 동시성: 여러 작업을 번갈아가면서 처리하는 것
    - 여러 작업이 논리적으로 동시에 실행되는 것처럼 보이는 개념
    - 시분할 방식으로 여러 스레드를 활용해 동시성을 구현할 수 있음
- 병렬성: 여러 작업을 실제로 동시에 처리하는 것
    - 여러 작업이 물리적으로 동시에 실행되는 개념
    - 멀티코어 환경에서 실제로 여러 스레드가 병렬로 실행될 수 있음
- 임의의 순서로 또는 동시에 작업이 실행될 수 있다
- 비동기를 처리하는 방법에는 Thread, callback, Future 방식이 있다
- kotlin에는 Coroutine이 있다

### Thread

- 현재 thread 확인 `Thread.currentThread`
- 단일 thread의 문제점
    - 모든 인스턴스는 main thread에서 생성되며 처리 된다
    - thread를 block하는 동안(sleep 메서드) 프로그램이 멈춘다

### 코루틴의 등장

- kotlin 1.3에 추가
- 경량
- 메모리 누수 감소
- 기본 제공 취소 지원
- Jetpack 통합
- 구글은 이후에 비동기 처리 방식은 kotlin과 coroutine을 권장하게 됨
- 자바로 개발할 때 최대 단점은 coroutine을 쓸 수 없는 것

### Coroutine

- Kotlin 표준 병행 프로그래밍 API
- coroutine은 오래 걸리는 작업을 수행하는 방법 중 우아하고 효율적인 방법 중 하나이다
- 콜백 기반 코드를 순차 코드로 변환할 수 있다
- 순차 코드는 읽기 쉽고 에러 처리가 편하다
- 일반적인 멀티태스킹과 코루틴
    - 일반적으로는 하나의 코루틴이 특정한 스레드에서 동작
    - 코틀린 코루틴은 `suspend`와 `resume`을 통해 스레드를 양보한다
    - 코루틴은 비동기식이며 스레드를 차단하지 않는다
    - 코루틴은 일시 중단 함수를 사용하여 비동기 코드를 순차적으로 만든다
- coroutine 사용시 이점
    - 경량: 코루틴은 실행 중인 스레드를 차단하지 않는 정지(suspend)를 지원하여 메모리를 절약하면서 많은 동시 작업을 처리
    - 메모리 누수 감소: 스레드를 활용한 동기화는 휴먼 에러에 의한 메모리 누수나 데드락과 같은 위험이 존재하지만, 코루틴은 안전
    - 스레드보다 가볍고 효율적이다
    - 많은 안드로이드 API가 지원하고 있다
- 주요 컨셉
    - 다른 언어의 async, await 같은 키워드가 제공되지 않는다
    - 대신 정지 함수를 활용한 안전하고 에러가 발생하지 않는 비동기 처리에 중점을 두고 있음
- 코로틴 빌더
    - launch
        - 반환값: Job
        - 용도: 결과가 필요 없는 비동기 작업
    - async
        - 반환값: Deferred<T>
        - 용도: 결과가 필요한 비동기 작업
    - runBlocking
        - 반환값: T
        - 용도: 코루틴과 일반 코드 연결
- delay
    - `suspend`함수는 일정시간 코루틴을 일시 정지함
    - 코루틴이 정지되어도 main thread는 차단되지 않음
    - `suspend`함수는 `CoroutineScope`블록 또는 다른 `suspend`함수에서 호출 가능
- suspend
    - 비동기 함수를 표기하는 코틀린 문버
    - suspend 함수가 실행되는 완료될 때까지 일시 중지 됨
    - 그 사이 다른 함수나 코루틴이 실행될 수 있음
- Job
    - CoroutineBuilder에 의해 작성된 코루틴
    - launch는 Job을 리턴한다
    - Job을 통해 실행중인 코루틴을 제어할 수 있다
    - `join()`은 해당 코루틴내의 처리가 끝나는 것을 기다린다
    - `cancel()`을 통해 코루틴 취소 가능

### Dispatcher

- 코루틴이 어떤 스케줄러에 의해 수행될지를 지정할 수 있다
- Default
    - 백그라운드 스레드
    - 코어 수에 비례해서 스레드를 만든다. 연산용
    - CPU에 부하를 줄 만한 처리(로컬에서 List 정렬 등)
- Main
    - 메인 스레드에 연결되는 디스패처
    - UI 갱신, 사용자 입력 처리
- IO
    - 백그라운드 스레드
    - Input/Output 조작용
    - 상대적으로 많은 스레드를 만드는 디스패처(DB통신/Http통신)
- Unconfied
    - 특정 스레드를 한정하지 않음. 공식 문서에서는 보통 사용하지 않는다고 명시되어 있음
- withContext() 함수: 디스패처를 전환해 주는 함수

## 💻 예제 코드

[비동기 처리 방식](../../src/main/kotlin/day13)

## 🔍 참고 자료

[kotlin coroutine](https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects)

## ❓ 궁금한 점

- 코루틴의 병렬 처리 과정
    - 하나의 루틴이 스레드 리소스를 다 차지한다고 가정한다면 벙렬처리는 어떻게 하나요?

## 💡 기타 사항