# 2025-01-03

## 📚 오늘 배운 내용
### 비동기 프로그래밍
- 비동기 프로그래밍
  - 여러 작업이 병렬로 실행 (순서 예측 x)
  - I/O 작업이나 네트워크 요청과 같이 시간이 오래 걸리는 작업에 유용
    - Thread
    - 콜백
    - Future
    - Coroutine
- 동기 vs 비동기 ) 작업 완료를 기다리는 방식의 차이
  - 동기 : 한 작업이 끝날 때까지 기다렸다가 다음 작업을 시작함
  - 비동기 : 기다리지 않고 다른 작업을 시작함
- 동시성 vs 병렬성 ) 여러 작업을 처리하는 방식에 대한 차이
  - 동시성 Concurrency : 여러 작업을 번갈아가면서 처리하는 것 (여러 스레드를 활용해 구현)
    - ex. 한 명의 교사가 여러가지 일을 순서대로 하는 것
  - 병렬성 Parallelism : 여러 작업을 실제로 동시에 처리하는 것 (멀티코어 환경에서 실제로 실행)
    - ex. 교사와 조교가 함께 동시에 일을 하는 것
- 비동기 단점
  - 디버깅이 어려움 
  - 끝나는 시간 예측 어려움
  - 따라서 비동기를 동기처럼 쓰려고 함
  - 콜백지옥
---
- 코루틴
  - 비동기식이며 스레드를 차단하지 않는다
  - suspend와 resume을 통해 스레드를 양보한다
  - 일시 중단 함수를 사용하여 비동기 코드를 순차적으로 만든다
  - 코루틴 빌더
    - 새로운 코루틴을 시작하는 함수 
    - 코루틴의 생명주기를 제한하는 CoroutineScope를 생성
      - runBlocking (현재 스레드를 블록). 코루틴과 일반 코드 연결   
        runBlocking은 내부 코루틴들이 모두 종료될 때까지 기다린다
      - launch (현재 스레드를 블록하지 않음). 결과가 필요없는 비동기 작업. 반환값 : job
        - async와의 차이점   
        async는 Deferred로 감싸서 결과를 반환한다
      ```kotlin
      fun main() = runBlocking {
        launch {
            delay(1000)
            println("world")
        }
        println("Hello")
      }
      // launch 로 새로운 코루틴을 시작해도 독립적으로 동작하기 때문에 Hello 가 먼저 출력된다
      ```
- 코루틴과 스레드의 차이점
  - 코루틴
    - 언어 레벨에서 구현된 경량 스케줄링 단위
    - 코루틴이 delay() 함수를 만나면 해당 코루틴의 실행이 일시 중단되고, 다른 코루틴에게 실행 기회를 양보한다
    - 코루틴 자체는 메모리에 남아있으며, 필요한 시점에 다시 실행될 수 있다
    - 코루틴은 운영체제의 스케줄링에 의존하지 않고, 코루틴 스케줄러에 의해 관리된다
      - delay()   
        코루틴을 일시 중단시키고, 다른 코루틴에게 실행 기회를 양보한다   
        메모리에 남아있기 때문에 다시 실행될 수 있으며, 시스템 자원을 효율적으로 사용한다
      - Dispatcher   
      코루틴이 어떤 스케줄러에 의해 수행될지 지정할 수 있다
      - withContext()   
      디스패처를 전환해주는 함수
  - 스레드
    - 운영체제에 의해 관리되는 스케줄링 단위
    - 스레드가 작업을 수행하다가 Thread.sleep()과 같은 메서드를 만나면, 해당 스레드 자체가 잠시 멈추고 운영체제는 다른 스레드에게 실행 기회를 넘겨준다
    - 즉, 스레드는 운영체제의 스케줄링에 의존하여 실행이 조절된다
      - Thread.sleep()   
        스레드를 잠시 멈추게 하지만, 해당 스레드가 할당받은 시스템 자원(CPU 시간 등)을 계속 점유하고 있어서 다른 스레드가 실행될 수 있도록 자원을 양보하지 않는다
- suspend : 일정시간 코루틴을 일시 정지한다. 그 사이 다른 함수나 코루틴이 실행될 수 있다

## 💻 예제 코드
<!-- 실습한 코드나 예제를 추가 -->
- 반환값 충돌
```kotlin
fun main():Unit = runBlocking {
    launch { kkou() }
    launch { kkack() }
    launch { jjack() }
}
```
launch 반환값은 job객체인데 runBlocking 반환값은 Unit(반환값 없음)이라 충돌이 생긴다. 따라서 main(): Unit을 명시해주어야 된다   
```kotlin
fun main() {
    runBlocking {
        launch { kkou() }
        launch { kkack() }
        launch { jjack() }
    }
}
```
또는 메인 함수 내부에 runBlocking을 작성하면 된다

## 🔍 참고 자료

## ❓ 궁금한 점

- 

---

### 회고

- 

### Follow up

- 